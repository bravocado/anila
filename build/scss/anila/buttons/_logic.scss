@import "vars";

@mixin button-base($display:$button-display) {
  display: $button-display;
  margin-bottom: 0; // For input.btn
  font-weight: $button-font-weight;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  background-image: none; // Reset unusual Firefox-on-Android default style; see https://github.com/necolas/normalize.css/issues/214
  //border: 1px solid transparent;
  white-space: nowrap;
  text-decoration: none !important;
  -webkit-touch-callout: none;
  background-clip: padding-box;
  //letter-spacing: -1px;
  @include user-select(none);
  &:focus {
    outline: none;
  }
}

@mixin button-size($padding:$button-md, $full-width:false, $is-input:false) {

  // We control which padding styles come through,
  // these can be turned off by setting $padding:false
  @if $padding {
    @include unit(padding-top, $padding);
    @include unit(padding-#{$opposite-direction}, $padding * 2);
    @include unit(padding-bottom, $padding);
    @include unit(padding-#{$default-float}, $padding * 2);

    // We control the font-size based on mixin input.
    @if      $padding == $button-md { @include unit(font-size, $button-font-md); }
    @else if $padding == $button-tn { @include unit(font-size, $button-font-tn); }
    @else if $padding == $button-sm { @include unit(font-size, $button-font-sm); }
    @else if $padding == $button-lg { @include unit(font-size, $button-font-lg); }
/*     @else                            { font-size: $padding - rem-calc(2); } */
  }

  // We can set $full-width:true to remove side padding extend width.
  @if $full-width {
    // We still need to check if $padding is set.
    @if $padding {
    //padding-top: $padding;
    //padding-bottom: $padding + rem-calc(1);
    @include unit(padding-bottom, $padding);
    @include unit(padding-bottom, $padding + strip-unit(rem-calc(1)));
    } @else if $padding == false {
      padding-top:0;
      padding-bottom:0;
    }
    padding-right: 0;
    padding-left: 0;
    width: 100%;
  }

  // <input>'s and <button>'s take on strange padding. We added this to help fix that.
  @if $is-input == $button-lg {
    //padding-top: $is-input + rem-calc(.5);
    //padding-bottom: $is-input + rem-calc(.5);
    @include unit(padding-top, $is-input);
    @include unit(padding-bottom, $is-input);
    -webkit-appearance: none;
    border: none; 
    font-weight: $button-font-weight !important;
  }
  @else if $is-input {
    //padding-top: $is-input + rem-calc(1);
    //padding-bottom: $is-input;
    @include unit(padding-top, $is-input);
    @include unit(padding-bottom, $is-input);
    -webkit-appearance: none;
    border: none; 
    font-weight: $button-font-weight !important;
  }

}

@mixin button-shape($shape: hard) {
  // shape
  @if $shape == hard {
    @include vendor(border-radius, 0px);
  }
  @if $shape == soft {
    @include vendor(border-radius, $button-radius-base);
  }
  @if $shape == extra-soft {
    @include vendor(border-radius, $button-radius-large);
  }
  @if $shape == round {
    @include vendor(border-radius, $button-round);
  }
}


@mixin anila-button($btn-color: $primary-color, $style: flat, $gradient-type: overlay, $shape: no-radius) {
  // base color adjust
  $color-type: if(yiq-contrast-color($btn-color, #000, #fff) == #000, "light", "dark");
  $color-adjust: if($color-type == "light", 5, -5);
  $gradient-color: photoshop-gradient-overlay($btn-color, $gradient-type, 50%, 90deg);
  
  //text shadow color adjust
  $text-shadow-adjust: if($color-type == "light", 20, -20);
  $text-shadow: adjust-color($btn-color, $lightness: $text-shadow-adjust);

  // shadow color normal adjust
  $shadow-color: yiq-contrast-color($btn-color, #fff, #000);

  // hover color adjust
  $hover-color: adjust-color($btn-color, $lightness: $color-adjust);

  // active state adjust
  $active-color-adjust: if($color-type == "light", 10, -10);
  $active-color: adjust-color($btn-color, $lightness: $active-color-adjust);

  @if $style == flat {
    @include yiq-contrasted($btn-color);
    @include single-transition(background-color, 400ms, ease-in-out);
    &:hover {
      background-color: $hover-color;
    }
    &:active {
      background-color: $active-color;
    }
  }
  @if $style == pretty {
    @include background-image($gradient-color);
    @include yiq-contrasted($btn-color);
    border: 1px solid $btn-color;
    @include vendor(box-shadow, inset 0 0 5px rgba($shadow-color, .5));
    @include vendor(text-shadow, -1px 1px 1px rgba($text-shadow, .8));
    @include single-transition(background-color, 200ms, ease-in-out);
    &:hover {
      background-color: $hover-color;
    }
    &:active {
      @include vendor(box-shadow, inset 0 2px 6px rgba(0, 0, 0, .3));
      background-color: $active-color;
    }
  }
  @if $style == shiny {
    $gradient-color:  photoshop-gradient-overlay($btn-color, normal, 100%, -90deg, 100%, (adjust-color($btn-color, $lightness: 10) 0%, adjust-color($btn-color, $lightness: 10) 50%, $btn-color 50%, $btn-color 100%));
    @include background-image($gradient-color);
    @include yiq-contrasted($btn-color);
    border: 1px solid adjust-color($btn-color, $lightness: 10);
    @include vendor(box-shadow, inset 0 3px 5px rgba(255, 255, 255, .5));
    @include vendor(text-shadow, 2px 0 2px rgba($text-shadow, .9));
    @include single-transition(background-color, 400ms, ease-in-out);
    &:hover {
      $color-adjust: if($color-type == "dark", 2, -2);
      $hover-color: adjust-color($btn-color, $lightness: $color-adjust);
      $gradient-color: photoshop-gradient-overlay($hover-color, normal, 100%, -90deg, 100%, (adjust-color($hover-color, $lightness: 10) 0%, adjust-color($hover-color, $lightness: 10) 50%, $hover-color 50%, $hover-color 100%));
      @include background-image($gradient-color);
      background-color: $hover-color;
    }
    &:active {
      $color-adjust: if($color-type == "dark", 5, -5);
      $hover-color: adjust-color($btn-color, $lightness: $color-adjust);
      $gradient-color: photoshop-gradient-overlay($hover-color, normal, 100%, -90deg, 100%, (adjust-color($hover-color, $lightness: 10) 0%, adjust-color($hover-color, $lightness: 10) 50%, $hover-color 50%, $hover-color 100%));
      @include background-image($gradient-color);
      background-color: $hover-color;
    }
  }
  @if $style == bordered {
    @include yiq-contrasted(rgba(255, 255, 255, 0));
    @include single-transition(border-color, 400ms, ease-in-out);
    border: 3px solid $btn-color;
    &:hover, &:focus {
      border: 3px solid $hover-color;
    }
    &:active {
      border: 3px solid $active-color;
    }
  }

  // shape
  @if $shape == base-radius {
    @include vendor(border-radius, $button-radius-base);
  }
  @if $shape == small-radius {
    @include vendor(border-radius, $button-radius-small);
  }
  @if $shape == large-radius {
    @include vendor(border-radius, $button-radius-large);
  }
  @if $shape == round {
    @include vendor(border-radius, $button-round);
  }
}

button.btn {
  border: 0;
  &:focus {
    outline: none;
  }
}

// experimental

// creating a class with predefined colors and class
@mixin button-precomposed($btn-color: $button-color-list, $btn-style: $button-style-list, $gradient-type: overlay, $btn-shape: $button-shape-list, $btn-size: $button-size-list) {
  
  .#{$base-button-class} {
    @include button-base($display: inline-block);
    // box-sizing
    @include box-sizing(border-box);

    // size
    @include button-size($button-md, false, false);
    // creating a colors and classes
    @each $bc in $btn-color {
      &.#{nth($bc, 1)} {
        @include yiq-contrasted(nth($bc, 2));
        @include single-transition(background-color, 200ms, ease-in-out);
        // creating style based on list
        &:hover {
          $hover-color: darken(nth($bc, 2), 5%);
          background-color: $hover-color;
        }
        &:active {
          $active-color: darken(nth($bc, 2), 10%);
          background-color: $active-color;
        }
        @each $bs in $btn-style {
          &.#{nth($bs, 1)} {
            // flat design
            @if #{nth($bs, 1)} == flat {
              @include anila-button($btn-color: nth($bc, 2), $style: flat);
            }
            // pretty design
            @if #{nth($bs, 1)} == pretty {
              @include anila-button($btn-color: nth($bc, 2), $style: pretty, $gradient-type: overlay);
            }
            // shiny design
            @if #{nth($bs, 1)} == shiny {
              @include anila-button($btn-color: nth($bc, 2), $style: shiny, $gradient-type: normal);
           }
             // bordered design
            @if #{nth($bs, 1)} == bordered {
              @include anila-button($btn-color: nth($bc, 2), $style: bordered, $gradient-type: normal);
            }
          }
        }
      }
      // end creating style
    }
    // end creating colors

    // creating sizes
    @each $bz in $btn-size {
      &.#{nth($bz, 1)} {
        @include button-size(nth($bz, 2), false, false);
      }
    }

    &.block {
      width: 100%;
      display: block;
    }
    //sizes

    // creating shapes
    @each $bp in $btn-shape {
      @if #{nth($bp, 1)} == hard {
        &.hard {
          @include button-shape(hard);
        }
      }
      @if #{nth($bp, 1)} == soft {
        &.soft {
          @include button-shape(soft);
        }
      }
      @if #{nth($bp, 1)} == extra-soft {
        &.extra-soft {
          @include button-shape(extra-soft);
        }
      }
      @if #{nth($bp, 1)} == round {
        &.round {
          @include button-shape(round);
        }
      }
    }
    // end chreating shape

  }
  // end each base button base
}
// end mixin precomposed

@if $use-button-precomposed  == true {
  @include button-precomposed;
}
